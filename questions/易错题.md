### 下面代码输出什么

```js
(function() {
   var a = b = 5;
})();

console.log(b);
```

<details>
  <summary>参考答案</summary>

  ```js
  5
  ```

</details>

### try..catch程序的输出结果

```js
(function () {
  try {
      throw new Error();
  } catch (x) {
      var x = 1, y = 2;
      console.log(x);
  }
  console.log(x);
  console.log(y);
})();
```
<details>
  <summary>参考答案</summary>

  ```js
  //输出结果
  1
  undefined
  2

  //分析
  (function () {
    var x,y;  // 外部变量提升
    try {
        throw new Error();
    } catch (x/* 内部的x */) {
        x = 1; //内部的x，和上面声明的x不是一回事！！
        y = 2; //内部没有声明，作用域链向上找，外面的y
        console.log(x); //当然是1
    }
    console.log(x);  //只声明，未赋值，undefined
    console.log(y);  //就是2了
  })();
  ```

</details>

### 下面代码输出什么

```js
var foo = 1;
(function foo(){
    foo = 100;
    console.log(foo);
}())
console.log(foo);
```

<details>
  <summary>参考答案</summary>

  ```js
  var foo = 1; // 在外部作用域声明foo=1

  // IIFE是典型的函数表达式
  (function foo(){ // 函数名foo，引用函数自身，绑定在函数内部，不污染外部作用域
      foo = 100; // 这里修改了foo，但规范规定不能修改，但不会报错
      console.log(foo); // 还是引用函数自身
  }())

  console.log(foo); // 外部作用域一直是1

  ```

 </details> 

 References:https://juejin.im/post/5cb75f56f265da03b11f2fe7
