# Web综合问题

## 目录

* [请描述一个网页从开始请求到最终显示的完整过程](#请描述一个网页从开始请求到最终显示的完整过程)
* [项目中做过哪些优化](#项目中做过哪些优化)
* [函数节流实现原理](#函数节流实现原理)

### 请描述一个网页从开始请求到最终显示的完整过程

一个网页从请求到最终显示的完整过程一般可分为如下 7 个步骤:

1. 在浏览器中输入网址;
1. 发送至 DNS 服务器并获得域名对应的 WEB 服务器的 IP 地址;
1. 与 WEB 服务器建立 TCP 连接;
1. 浏览器向 WEB 服务器的 IP 地址发送相应的 HTTP 请求;
1. WEB 服务器响应请求并返回指定 URL 的数据,或错误信息,如果设定重定向,则重定向到新的 URL 地址。
1. 浏览器下载数据后解析 HTML 源文件,解析的过程中实现对页面的排版,解析完成后在浏览器中显示基础页面。
1. 分析页面中的超链接并显示在当前页面,重复以上过程直至无超链接需要发送,完成全部显示。

[[↑] Back to top](#web综合问题)

### 项目中做过哪些优化

比如从客户端着手的:

 1. 压缩代码(JS/CSS),压缩图片
 1. 合并一些小图片(css sprite)
 1. 若是打包的代码尽可能切割成多个 chunk,减少单一 chunk过大
 1. 静态文件采用 cdn 引入
 1. HTTP的缓存头使用的合理
 1. 减小第三方库的依赖
 1. 对于代码应该考虑性能来编写,比如使用requestAnimationFrame绘制动画,尽可能减少页面重绘(DOM 改变)
 1. 渐进升级,引入preload这些预加载资源
 1. 看情况用server worker来缓存资源(比如移动端打算搞 PWA)

比如从服务端着手:

1. 带宽,域名解析, 多域名解析等
1. 页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)
1. 渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)

[[↑] Back to top](#web综合问题)

### 函数节流实现原理

```js
function throttle(method, context) {
     clearTimeout(methor.tId);
     method.tId = setTimeout(function(){
         method.call(context);
     }， 100);
 }
```

调用

```js
window.onresize = function(){
    throttle(myFunc);
}
```

参考：

* [https://segmentfault.com/a/1190000009472348](https://segmentfault.com/a/1190000009472348)

[[↑] Back to top](#web综合问题)
